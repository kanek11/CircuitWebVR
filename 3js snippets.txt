

***
 var camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );


***
const geometry = new THREE.BoxGeometry( 1, 1, 1 );
const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
const mesh = new THREE.Mesh( geometry, material );
scene.add( mesh );


***

const geometry = new THREE.BufferGeometry();

const vertices = new Float32Array( [
       -1.0, -1.0,  1.0, // v0
        1.0, -1.0,  1.0, // v1
        1.0,  1.0,  1.0, // v2
       -1.0,  1.0,  1.0, // v3
] );

const indices = [
       0, 1, 2,
       2, 3, 0,
];

geometry.setIndex( indices );
geometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );



***

THREE.MeshBasicMaterial({
        color: 0xff0000,
        wireframe: true,
        map:
        side:THREE.DoubleSide, //for planes
      });


THREE.MeshPhongMaterial({
  shininess: 30,
  map: texture,
  specularMap:  specularTex,
  envMap: cubeTex,
  transparent: true, 
  opacity: 0.4,


  THREE.MeshStandardMaterial({
    map: albedoMap,             
    metalnessMap: metalnessMap,  
    roughnessMap: roughnessMap, 
    normalMap: normalMap         
});



THREE.MeshLambertMaterial({
  color: 0x00ff00,
});


THREE.LineBasicMaterial(
{ color: 0x000000, 
transparent: true, 
opacity: 0.5 });


****

const MAX_POINTS = 500;

// geometry
const geometry = new THREE.BufferGeometry();

// attributes
const positions = new Float32Array( MAX_POINTS * 3 ); // 3 floats (x, y and z) per point
geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );

// draw range
const drawCount = 2; // draw the first 2 points, only
geometry.setDrawRange( 0, drawCount );

// material
const material = new THREE.LineBasicMaterial( { color: 0xff0000 } );

// line
const line = new THREE.Line( geometry, material );
scene.add( line );




const positionAttribute = line.geometry.getAttribute( 'position' );

let x = 0, y = 0, z = 0;

for ( let i = 0; i < positionAttribute.count; i ++ ) {

	positionAttribute.setXYZ( i, x, y, z );

    x += ( Math.random() - 0.5 ) * 30;
    y += ( Math.random() - 0.5 ) * 30;
    z += ( Math.random() - 0.5 ) * 30;

}



***


const composer = new EffectComposer( renderer );

const renderPass = new RenderPass( scene, camera );
composer.addPass( renderPass );

const glitchPass = new GlitchPass();
composer.addPass( glitchPass );

const outputPass = new OutputPass();
composer.addPass( outputPass );

function animate() {

	requestAnimationFrame( animate );

	composer.render();

}



***

object.position.copy( start_position );
object.quaternion.copy( quaternion );
 
object.matrixAutoUpdate = false; 
object.updateMatrix();